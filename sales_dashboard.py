# -*- coding: utf-8 -*-
"""sales_dashboard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14AsWfdjuaRXLhLF1il0pVzf84OEPD8wa
"""


# sales_dashboard.py

import streamlit as st
import pandas as pd
import plotly.express as px
from prophet import Prophet

st.set_page_config(page_title="Sales Dashboard", layout="wide")
st.title("📊 Sales Dashboard - Sample Sales Data")

# Upload CSV
uploaded_file = st.file_uploader("Upload your 'sales_data_sample.csv' file", type=["csv"])
if uploaded_file:
    try:
        df = pd.read_csv(uploaded_file, encoding='latin1', parse_dates=['ORDERDATE'])
    except Exception as e:
        st.error(f"Error loading file: {e}")
        st.stop()

    # Sidebar filters
    with st.sidebar:
        st.header("🧰 Filter Data")
        region = st.multiselect("Select Territory", df['TERRITORY'].dropna().unique(), default=df['TERRITORY'].dropna().unique())
        product = st.multiselect("Select Product Line", df['PRODUCTLINE'].unique(), default=df['PRODUCTLINE'].unique())
        date_range = st.date_input("Select Date Range", [df['ORDERDATE'].min(), df['ORDERDATE'].max()])

    # Filtered data
    filtered_df = df[
        (df['TERRITORY'].isin(region)) &
        (df['PRODUCTLINE'].isin(product)) &
        (df['ORDERDATE'] >= pd.to_datetime(date_range[0])) &
        (df['ORDERDATE'] <= pd.to_datetime(date_range[1]))
    ]

    if filtered_df.empty:
        st.warning("⚠️ No data matches the selected filters.")
        st.stop()

   # Setup Tabs 
    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        "📈 Overview", "📊 Visualizations", "🌍 Top Insights", "📋 Data & Export", "📈 Forecasting"
    ])


    # --- TAB 1: OVERVIEW ---
    with tab1:
        st.subheader("Key Performance Indicators")
        total_sales = filtered_df['SALES'].sum()
        total_units = filtered_df['QUANTITYORDERED'].sum()
        avg_unit_cost = filtered_df['PRICEEACH'].mean()
        most_popular = filtered_df.groupby("PRODUCTLINE")["QUANTITYORDERED"].sum().idxmax()
        best_region = filtered_df.groupby("TERRITORY")["SALES"].sum().idxmax()

        col1, col2, col3 = st.columns(3)
        col1.metric("Total Sales ($)", f"{total_sales:,.2f}")
        col2.metric("Total Units Sold", f"{total_units:,}")
        col3.metric("Avg. Unit Cost ($)", f"{avg_unit_cost:,.2f}")

        col4, col5 = st.columns(2)
        col4.metric("Most Popular Product", most_popular)
        col5.metric("Top Performing Region", best_region)

    # --- TAB 2: VISUALIZATIONS ---
    with tab2:
        st.subheader("Sales by Product Line")
        product_sales = filtered_df.groupby("PRODUCTLINE")["SALES"].sum().reset_index().sort_values(by="SALES", ascending=False)
        fig1 = px.bar(product_sales, x="PRODUCTLINE", y="SALES", color="PRODUCTLINE", text_auto=".2s")
        fig1.update_layout(yaxis_tickprefix="$")
        st.plotly_chart(fig1, use_container_width=True)

        st.subheader("Sales Over Time")
        time_series = filtered_df.groupby("ORDERDATE")["SALES"].sum().reset_index().sort_values("ORDERDATE")
        fig2 = px.line(time_series, x="ORDERDATE", y="SALES", markers=True)
        fig2.update_layout(yaxis_tickprefix="$")
        st.plotly_chart(fig2, use_container_width=True)

        st.subheader("Monthly Sales Trend")
        monthly_df = filtered_df.copy()
        monthly_df['Month'] = monthly_df['ORDERDATE'].dt.to_period('M').astype(str)
        fig_month = px.bar(monthly_df.groupby("Month")["SALES"].sum().reset_index(), x="Month", y="SALES")
        fig_month.update_layout(yaxis_tickprefix="$")
        st.plotly_chart(fig_month, use_container_width=True)

        st.subheader("Product Line Share (Pie Chart)")
        fig_pie = px.pie(product_sales, names='PRODUCTLINE', values='SALES', hole=0.4)
        st.plotly_chart(fig_pie, use_container_width=True)

    # --- TAB 3: TOP INSIGHTS ---
    with tab3:
        st.subheader("Top 5 Performing Regions")
        top_regions = filtered_df.groupby("TERRITORY")["SALES"].sum().sort_values(ascending=False).head(5).reset_index()
        fig4 = px.bar(top_regions, x="TERRITORY", y="SALES", color="TERRITORY", text_auto=".2s")
        fig4.update_layout(yaxis_tickprefix="$")
        st.plotly_chart(fig4, use_container_width=True)

        st.subheader("Top 5 Products by Revenue")
        top_products = filtered_df.groupby("PRODUCTLINE")["SALES"].sum().sort_values(ascending=False).head(5).reset_index()
        fig5 = px.bar(top_products, x="PRODUCTLINE", y="SALES", color="PRODUCTLINE", text_auto=".2s")
        fig5.update_layout(yaxis_tickprefix="$")
        st.plotly_chart(fig5, use_container_width=True)

        st.subheader("Average Unit Price by Product Line")
        avg_price = filtered_df.groupby("PRODUCTLINE")["PRICEEACH"].mean().reset_index()
        fig6 = px.bar(avg_price, x="PRODUCTLINE", y="PRICEEACH", color="PRODUCTLINE", text_auto=".2f")
        fig6.update_layout(yaxis_tickprefix="$")
        st.plotly_chart(fig6, use_container_width=True)

    # --- TAB 4: DATA TABLE + EXPORT ---
    with tab4:
        st.subheader("Filtered Sales Records")
        st.dataframe(filtered_df.style.background_gradient(cmap="YlGnBu", subset=["SALES", "QUANTITYORDERED"]))

        csv = filtered_df.to_csv(index=False).encode('utf-8')
        st.download_button("📥 Download Filtered Data", csv, "filtered_sales.csv", "text/csv")
    
    
    # === FORECASTING TAB ===
    with tab5:
        st.subheader("Sales Forecasting by Product Line")
    
        # Let user select product line and forecast horizon
        selected_product = st.selectbox("Select a Product Line", df['PRODUCTLINE'].unique())
        forecast_period = st.slider("Forecast Horizon (in months)", 1, 12, value=6)
    
        # Filter and prepare data
        forecast_df = df[df['PRODUCTLINE'] == selected_product]
        ts_data = forecast_df.groupby("ORDERDATE")["SALES"].sum().reset_index()
        ts_data.columns = ['ds', 'y']  # Required format for Prophet
    
        if len(ts_data) < 30:
            st.warning("⚠️ Not enough data to forecast. Try another product line.")
        else:
            with st.spinner("Training Prophet model..."):
                model = Prophet()
                model.fit(ts_data)
    
                future = model.make_future_dataframe(periods=forecast_period * 30)
                forecast = model.predict(future)
    
            # Plot Forecast with confidence intervals
            st.subheader(f"📊 {selected_product} Sales Forecast ({forecast_period} months ahead)")
            fig = px.line(forecast, x="ds", y="yhat", title="Predicted Sales with Confidence Intervals")
            fig.add_scatter(x=forecast['ds'], y=forecast['yhat_upper'], mode='lines', name='Upper Bound')
            fig.add_scatter(x=forecast['ds'], y=forecast['yhat_lower'], mode='lines', name='Lower Bound')
            fig.update_layout(xaxis_title="Date", yaxis_title="Sales", yaxis_tickprefix="$")
            st.plotly_chart(fig, use_container_width=True)
    
            # Display numeric prediction
            last_forecast = forecast.iloc[-1]
            st.markdown(f"""
            ### 🔍 Forecast Summary
            - Predicted Sales (end of period): **${last_forecast['yhat']:.2f}**
            - Confidence Interval: **${last_forecast['yhat_lower']:.2f} – ${last_forecast['yhat_upper']:.2f}**
            - Model: Facebook Prophet
            """)
    
            # Show seasonal components
            st.subheader("📉 Forecast Components")
            fig2 = model.plot_components(forecast)
            st.pyplot(fig2)


else:
    st.info("👆 Please upload the 'sales_data_sample.csv' file to begin.")


